import os
import requests
import json

from rich import print
from rich.console import Console
from rich.markdown import Markdown
from rich.prompt import Prompt
from rich.prompt import IntPrompt
from rich.prompt import Confirm
from rich.padding import Padding
from rich.style import Style
from rich.markup import escape

from config import Config



# SETUP
console = Console(width=100)
conf = Config()



# UI SETUP
def get_style():
    """
    Gets style setting from bow_style.txt

    :return: Boolean saying if 'black on white' style should be used.
    """ 
    app_path = os.getcwd()
    file_path = f"{app_path}/bow_style.txt"
    if os.path.exists(file_path):
        with open(file_path, 'r') as file:
            bow_style = str(file.read())
            if bow_style.lower() == "true":
                style_bool = True
            else:
                style_bool = False
            return style_bool
    else:
        return False



# this setings have to be placed after get_style() function, otherwise style
# won't be applied to the functions below

style_bool = get_style()

if conf.black_on_white_style == True or style_bool == True:
    os.system('color F0')
    style_used = conf.style_types['bow']

else:
    style_used = conf.style_types['default']



def add_input(text):
    """
    Gets a single user str input using Rich

    :return: the input string
    """ 
    console.print(Padding(f'{text}', (1, 2, 1, 3)), style=style_used)
    added_input = Prompt.ask() 
    return added_input



def add_inputs(text):
    """
    Gets several user string inputs, turns them into a list and returns.

    :return: A list of input strings.
    """ 
    inputs = []
    console.print(Padding(f'''{text} If that's all, and you want me to start generating a response, write: "ok":''', (1, 2, 1, 3)), style=style_used)
    while True:
        idea_input = Prompt.ask()
        if idea_input.lower() == "ok":
             inputs.append(' ')
             break
        elif idea_input.lower() == "skip":
            return ["skip"]
        else:            
            inputs.append(idea_input)
    return inputs



def random_words(number):
    """
    Downloads random words from https://random-word-api.herokuapp.com/word, turns them into a string, returns

    :param number: int of how many words should be downloaded
    :return: Random words separated by ',' in a single string
    """ 
    random = requests.get(f'https://random-word-api.herokuapp.com/word?number={number}')
    return ', '.join(json.loads(random.text))



def printout(the_world, chapters, definitions, substitutions):
    """
    Prints the text generated by the module in the console.
    
    :param the_world: the world description as string
    :param chapters: chapters as dictionary (keys: chapter titles, values: chapter text as str)
    :param definitions: word definitions as string
    :param substitutions: suggested substitutions as string
    """ 
    try:
        console.print(Padding(the_world, (1, 2, 1, 3)), style=style_used)
    except: 
        pass
    
    try:
        for key, value in chapters.items():
            console.print(Padding(f'{key.upper()} {value}', (1, 2, 1, 3)), style=style_used)
    except:
        pass
    
    try:
        console.print(Padding(f'{definitions} {substitutions}', (1, 2, 1, 3)), style=style_used)
    except:
        pass    



def rollback(memory):
    """
    Asks for a reversed index of element in in-app memory (a dict, keys: memory index as int, 
    values: memory content as string), prints this memory in console, asks if this memory should
    be made the primary world description, returns a bool of the user response and either the
    string from memory (if user wants the memory to replace the current description) or empty string
    (if user's response was negative) 

    :param memory: in-app memory as dictionary (keys: memory index as int, values: memory content as string)
    :return: a tuple containing a bool of user's response to the question if the current world description
            should be replaced by one from memory and a string with the description of the world (if the 
            bool = 'True' or an empty string(if the bool = 'False)
    """ 
    console.print(Padding('How far should I roll back?', (1, 2, 1, 3)), style=style_used)
    world_number = IntPrompt.ask()
    world_number = -(world_number)
    try:
        console.print(Padding(memory[world_number], (1, 2, 1, 3)), style=style_used)
        console.print(Padding('Do you want to make this world the primary one', (1, 2, 1, 3)), style=style_used)
        if Confirm.ask() == True:
            return (True, memory[world_number])
        else:
            return (False, '')
    except:
        console.print(Padding('Sorry, no such world! Try again.', (1, 2, 1, 3)), style=style_used)
        return (False, '')



def extract_data():
    """
    Asks for a number of file with a world description, if it exists loads it and cuts into pieces containing: 
    the world description, chapters, definitions, substitutions, memory, and input_sum (user's input on which the world's
    description was based. Returns all those elements. 

    :return: if the file exists returns worlds description(string), chapters(dict), definitions(string), substitutions(string),
            memory(dict), input_sum(list of strings). If the file cannot be found returns bool = 'False'.
    """ 
    console.print(Padding('What number does the file have (e.g. my_world_3.txt is number 3)?', (1, 2, 1, 3)), style=style_used)
    file_number = IntPrompt.ask() 
    app_path = os.getcwd()
    file_path = f"{app_path}\saved worlds\my_world_{file_number}.txt"
    try:
        with open(file_path, 'r') as file:
            saved_data = file.read()
            the_world = saved_data.split('------------------------')[0]
            chapters = saved_data.split('CHAPTERS: ')[1].split('------------------------')[0]
            definitions = saved_data.split('DEFINITIONS: ')[1].split('------------------------')[0]
            substitutions = saved_data.split('SUBSTITUTIONS: ')[1].split('------------------------')[0]
            memory = saved_data.split('MEMORY: ')[1].split('------------------------')[0]
            input_sum = saved_data.split('INPUT SUM: ')[1].split('------------------------')[0]
            return the_world[8:], chapters, definitions, substitutions, memory, input_sum
    except:
        console.print(Padding('No such file or other problem encountered.', (1, 2, 1, 3)), style=style_used)
        return False



def save_to_file(the_world, chapters, definitions, substitutions, memory, input_sum):
    """
    Saves the world description and other elements (chapters, definitions, substitutions, memory, input_sum)
    to a txt file in app_folder\data\my_world_x where x is the number of the file (it checks what file numbers
    already exists and uses the first available number)
    
    :param the_world: the world description as string
    :param chapters: chapters as dictionary (keys: chapter titles, values: chapter text as str)
    :param definitions: word definitions as string
    :param substitutions: suggested substitutions as string
    :param memory: in-app memory as dict
    :param input_sum: user's input on which the world's description was based, list of strings
    """ 
    memory_string = '\n'.join(memory)
    saving_world = f'''WORLD: {the_world}\n------------------------\n\
                       CHAPTERS: {json.dumps(chapters)}\n------------------------\n\
                       DEFINITIONS: {definitions}\n------------------------\n\
                       SUBSTITUTIONS: {substitutions}\n------------------------\n\
                       MEMORY: {json.dumps(memory)}\n------------------------\n\
                       INPUT SUM: {json.dumps(input_sum)}'''
    app_path = os.getcwd()
    subdir_path = os.path.join(app_path, "saved worlds")
    if not os.path.exists(subdir_path):
        os.makedirs(subdir_path)
    x = 1
    file_path = os.path.join(subdir_path, f"my_world_{x}.txt")
    while os.path.exists(file_path):
        x += 1
        file_path = os.path.join(subdir_path, f"my_world_{x}.txt")
    with open(file_path, "w") as f:
        f.write(saving_world)
    console.print(Padding(f"Saved as: {file_path}", (1, 2, 1, 3)), style=style_used)



def get_aikey():
    """
    Gets openai key from app folder\aikey.txt, reutrns it.

    :return: the openai key as string
    """ 
    app_path = os.getcwd()
    file_path = f"{app_path}/aikey.txt"
    if os.path.exists(file_path):
        with open(file_path, 'r') as file:
            aikey = str(file.read())
            return aikey
    else:
        console.print(Padding("I'm sorry but I can't find the openai api key. Please provide it by \
                                placing it in config.openai_key, setting an envirnomental variable \
                                or placing it in aikey.txt file in the app folder.", (1, 2, 1, 3)), 
                                style=style_used)



